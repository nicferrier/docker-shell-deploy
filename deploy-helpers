#!/bin/bash

# Functions to help with docker deployment.
#
# function deploy rebuilds a dockerfile, pushes the image to docker
# and then pulls the same docker image on a remote host, rebinds the
# nginx config there and restarts nginx.
#
# function remoteDeploy is a helper function for operating on the
# remote host.


# This is the script run on the remote machine
# 
# Call with:
#
# $1  the docker image name, eg: nicferrier/elnode-gnudoc
# $2  the docker exported port which you will connect to nginx
# $3  the nginx config name that you'll connect to
# $4  docker volume mounts, like: "/host:/container /host:/container"
function remoteDeploy {
    # Check some stuff
    [ -x /etc/init.d/nginx ] || { echo "no nginx?" >&2 ; return 1; }
    [ -x $(which jq) ] || { echo "no jq?" >&2 ; return 1; }
    [ -x $(which docker || which docker.io) ] || { echo "no docker?" >&2 ; return 1; }

    local docker="sudo $(which docker || which docker.io)"
    local jq="(which jq)"

    local dockerImage=$1
    local dockerExPort=$2
    local nginxConfig=$3
    local dockerVolumes=$4

    # Pull the new dockers
    $docker pull $dockerImage

    # What's the current deploy hosted on?
    local currentIp=$(sudo sed -nre 's|.*proxy_pass http://([^;:]+).*|\1|p' $nginxConfig)
    [ "$currentIp" == "localhost" ] && currentIp="127.0.0.1"
    [ "${currentIp%%.*}" -gt 0 ] 2> /dev/null || currentIp=$(
        getent hosts $currentIp | ( read ip _ ; echo $ip )
    )
    echo "currentIp is $currentIp"

    local ETAG=$(date '+%Y%m%d%H%M%S%N')

    # Check docker volume mounts and turn them into docker opts
    [ -z $dockerVolumes ] || {
        echo $dockerVolumes | tr ' ' '\n' | tr ':' ' ' | while read host container
        do
            [ -d $host ] || { echo "$host should be a directory and isn't" >&2 ; return 1; }
        done

        # Everything ok? make a valid docker options string
        dockerVolumes=$(echo $dockerVolumes | sed -rne 's/^| / -v /pg')
        echo "dockerVolumes is: $dockerVolumes"

        # Kill for now
        exit 1;
    }

    # Start the new docker
    local containerId=$(
        $docker run -d --env ETAG=${ETAG} ${dockerVolumes} -t $dockerImage
    )
    local newIp=$($docker inspect $containerId | $jq -r '.[0] | .NetworkSettings.IPAddress')
    # FIXME we could curl check the new container after this

    # Rewrite the nginx config and restart
    sudo sed -ibk -re "s|proxy_pass http://[^:;]+:[0-9]+|proxy_pass http://$newIp:${dockerExPort}|" $nginxConfig
    sudo /etc/init.d/nginx reload

    # FIXME possibly curl here to check that the new one has worked?

    # Now find the old one and turn it off
    if [ ! -z $currentIp ]
    then
        $docker ps -q |  while read dockId
        do 
            ( $docker inspect -f '{{ .Config.Image }}' $dockId \
                | grep $dockerImage > /dev/null ) && echo $dockId
        done | while read dockId 
        do
            echo "$dockerImage $dockId docker found" >&2
            printf "$dockId " 
            $docker inspect $dockId | $jq -r '.[0] | .NetworkSettings.IPAddress'
        done | while read dockId ipAddress
        do
            echo "$dockId using $ipAddress" >&2
            [ "$currentIp" != "$ipAddress" ] && {
                echo "killing $dockId because it's not on $currentIp" >&2
                $docker kill $dockId;
            }
        done
    fi
}

# Function to the initial deploy
# 
# Call with:
#
# $1  the command, either "build" (just builds the docker)
#       or "push"  (builds and pushes to remote but doesn't restart)
#       or "deploy", the default, which builds, pushes and restarts
# $2  the docker image name to build
# $3  the docker exported port to connect to
# $4  the nginx config to hack on the remote
# $5  the host name of the remote
function deploy {
    [ -x $(which docker || which docker.io) ] || { echo "no docker?" >&2 ; return 1; }
    local docker="sudo $(which docker || which docker.io)"
    
    local command=$1
    local dockerImage=$2
    local dockerExPort=$3
    local nginxConfig=$4
    local hostName=$5

    cd $(dirname $0)
    [ -f Dockerfile ] || { echo "no Dockerfile?" >&2  ; return 1; }

    $docker build --no-cache -t $dockerImage .
    
    [ "$command" == "build" ] && echo "docker built" >&2 && exit 1
    
    $docker push $dockerImage
    
    [ "$command" == "push" ] && echo "docker pushed to $hostName" >&2 && exit 2
    
    # Now the remote parts
    ( typeset -fp remoteDeploy ; \
        echo remoteDeploy $dockerImage $dockerExPort $nginxConfig \
        ) | ssh $hostName bash -
}

# deploy ends here
